---
title: 蓝桥杯 2019年第十届省赛 C/C++ B组 J 灵能传输
date: 2021-04-12 18:47:37
tags:
- 前缀和
categories:
- 蓝桥杯
cover: https://cdn.jsdelivr.net/gh/love-ziji/CDN/post2.jpg
---

## 题目描述

【题目背景】
在游戏《星际争霸 II》中，高阶圣堂武士作为星灵的重要 AOE 单位，在游戏的中后期发挥着重要的作用，其技能”灵能风暴“可以消耗大量的灵能对一片区域内的敌军造成毁灭性的伤害。经常用于对抗人类的生化部队和虫族的刺蛇飞龙等低血量单位。
【问题描述】
你控制着 n 名高阶圣堂武士，方便起见标为 1, 2, · · · , n。每名高阶圣堂武士需要一定的灵能来战斗，每个人有一个灵能值 ai 表示其拥有的灵能的多少（ai 非负表示这名高阶圣堂武士比在最佳状态下多余了 ai 点灵能，ai 为负则表示这名高阶圣堂武士还需要 −ai 点灵能才能到达最佳战斗状态）。现在系统赋予了你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个 i ∈ [2, n − 1]，若 ai ≥ 0 则其两旁的高阶圣堂武士，也就是 i − 1、i + 1 这两名高阶圣堂武士会从 i 这名高阶圣堂武士这里各抽取 ai 点灵能；若 ai < 0 则其两旁的高阶圣堂武士，也就是 i − 1、i + 1 这两名高阶圣堂武士会给 i 这名高阶圣堂武士 −ai 点灵能，形式化来讲就是 ai−1 += ai, ai+1 += ai, ai −= 2ai。
灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为 max| ai |，请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武士的不稳定度最小。
【输入格式】
本题包含多组询问。输入的第一行包含一个正整数 T 表示询问组数。接下来依次输入每一组询问。
每组询问的第一行包含一个正整数 n，表示高阶圣堂武士的数量。
接下来一行包含 n 个数 a1, a2, · · · , an。
【输出格式】
输出 T 行。每行一个整数依次表示每组询问的答案。
【样例输入】
3
3
5 -2 3
4
0 0 0 0
3
1 2 3
【样例输出】
3
0
3
【样例说明】
对于第一组询问：
对 2 号高阶圣堂武士进行传输操作后 a1 = 3，a2 = 2，a3 = 1。答案为 3。
对于第二组询问：
这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。
【样例输入】
3
4
-1 -2 -3 7
4
2 3 4 -8
5
-1 -1 6 -1 -1
【样例输出】
5
7
4
【数据规模与约定】
对于所有评测用例，T ≤ 3，3 ≤ n ≤ 300000，| ai | ≤ 10^9。
评测时将使用 25 个评测用例测试你的程序，每个评测用例的限制如下：

| 评测用例编号 |    n     | \| ai \| |   特殊性质   |
| :----------: | :------: | :------: | :----------: |
|      1       |    =3    |  <=1000  |      无      |
|     2,3      |   <=5    |  <=1000  |      无      |
|   4,5,6,7    |   <=10   |  <=1000  |      无      |
|    8,9,10    |   <=20   |  <=1000  |      无      |
|      11      |  <=100   |  <=10^9  | 所有 ai 非负 |
|   12,13,14   |  <=100   |  <=10^9  |      无      |
|    15,16     |  <=500   |  <=10^9  |      无      |
|   17,18,19   |  <=5000  |  <=10^9  |      无      |
|      20      |  <=5000  |  <=10^9  | 所有 ai 非负 |
|      21      | <=100000 |  <=10^9  | 所有 ai 非负 |
|    22,23     | <=100000 |  <=10^9  |      无      |
|    24,25     | <=300000 |  <=10^9  |      无      |

注意：本题输入量较大请使用快速的读入方式。

## 题目分析

题目要求通过若干次灵能传递使max{|a[i]|}最小。
转化为前缀和形式，记为 s[1] ~ s[n]，此时的 a[1] ~ a[n] 变为 s[1], s[2] - s[1], s[3] - s[2], ... , s[n] - s[n - 1]，补上 s[0] = 0，使得a[1] = s[1] - s[0]
现若 i 号高阶圣堂武士传递灵能，s[i] -= 2a[i], s[i - 1] += a[i], s[i + 1] += a[i]，即s[i - 1] -> s[i], s[i] -> s[i - 1], s[i + 1] -> s[i + 1]，交换了 s[i - 1] 和 s[i]
如此，前缀和形式的传递灵能的操作是不是简单多了！
题目要求转化为任意交换 s[1] ~ s[n - 1]，使 s[1] - s[0], s[2] - s[1], s[3] - s[2], ... , s[n] - s[n - 1] 的绝对值的最大值最小。
如果能任意交换 s[0] ~ s[n]，显然排序后差的绝对值的最大值最小，但题目固定了 s[0] 和 s[n] 两点，即固定了起点和终点。
![](https://cdn.jsdelivr.net/gh/love-ziji/LANQIAO/201910.png)
排序后起点和终点一般情况下就不再是在两端，而是在中间，
我们设 min{ s[0], s[n] } 为起点，max{ s[0], s[n] } 为终点，保证排序后起点在终点左方，
取数以起点开始到最小值，再到最大值，最后到达终点。
两段重叠区也必须保证向左时和向右时差的绝对值的最大值最小，通过隔一个数取一个数解决。
取数完成后遍历一遍找到差的绝对值的最大值输出。

```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=300001;

int n;
long long s[N],a[N];
int vis[N];

int main()
{
	int T;
	scanf("%d",&T);
	while(T--) {
		s[0]=0;
		scanf("%d",&n);
		for(int i=1;i<=n;i++) {
			scanf("%lld",&s[i]);
			s[i]+=s[i-1]; //计算前缀和 
		}
		long long s0=s[0],sn=s[n];
		if(s0>sn) {
			swap(s0,sn);
		}
		sort(s,s+n+1);
		for(int i=0;i<=n;i++) { //寻找最小值下标 
			if(s[i]==s0) {
				s0=i;
				break;
			}
		}
		for(int i=n;i>=0;i--) { //寻找最大值下标 
			if(s[i]==sn) {
				sn=i;
				break;
			}
		}
		int p=0,q=n;
		memset(vis,0,sizeof(vis));
		// 取数 
		for(int i=s0;i>=0;i-=2) {
			a[p++]=s[i];
			vis[i]=1;
		}
		for(int i=sn;i<=n;i+=2) {
			a[q--]=s[i];
			vis[i]=1;
		}
		for(int i=0;i<=n;i++) {
			if(!vis[i]) {
				a[p++]=s[i];
			}
		}
		long long res=0;
		for(int i=1;i<=n;i++) {
			res=max(res,abs(a[i]-a[i-1]));
		}
		printf("%lld\n",res);
	}
	
	return 0;
}
```