---
title: 蓝桥杯 2018年第九届省赛 C/C++ B组 09 全球变暖
date: 2021-04-11 20:11:39
tags:
- 深度优先搜索
- 连通块
categories:
- 蓝桥杯
cover: https://cdn.jsdelivr.net/gh/love-ziji/CDN/post1.jpg
---

## 题目描述

你有一张某海域 N x N 像素的照片，"." 表示海洋、"#" 表示陆地，如下所示：
.......
.##....
.##....
....##.
..####.
...###.
.......
其中"上下左右"四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有 2 座岛屿。
由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。
例如上图中的海域未来会变成如下样子：
.......
.......
.......
.......
....#..
.......
.......
请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。
【输入格式】
第一行包含一个整数N。(1 <= N <= 1000)
以下 N 行 N 列代表一张海域照片。
照片保证第 1 行、第 1 列、第 N 行、第 N 列的像素都是海洋。
【输出格式】
一个整数表示答案。
【输入样例】
7
.......
.##....
.##....
....##.
..####.
...###.
.......
【输出样例】
1

## 题目分析

即：判断连通块（岛屿）中是否存在某个位置其相邻的四个方向皆为 '#'，若存在，则该连通块不会被淹没，否则该连通块会被淹没。
遍历整个海域，每遍历到一个未被访问过的 '#'，使用dfs搜索出整个连通块，边搜索边判断是否存在某个位置其相邻的四个方向皆为 '#'。

```c++
#include<iostream>
using namespace std;
const int N=1000;

int n;
char map[N][N];
int vis[N][N]={0};
int f[N*N]={0};

void dfs(int x,int y,int num) {
	if(x<0 || y<0 || x>=n || y>=n) {
		return;
	}
	if(map[x][y] == '.') {
		return;
	}
	if(vis[x][y]) {
		return;
	}
	vis[x][y]=1;
	if(map[x-1][y]=='#' && map[x+1][y]=='#' && map[x][y+1]=='#' && map[x][y-1]=='#') {
		f[num]++;
	}
	dfs(x-1,y,num);
	dfs(x+1,y,num);
	dfs(x,y+1,num);
	dfs(x,y-1,num);
}

int main()
{
	cin>>n;
	for(int i=0;i<n;i++) {
		for(int j=0;j<n;j++) {
			cin>>map[i][j];
		}
	}
	int num=0;
	for(int i=0;i<n;i++) {
		for(int j=0;j<n;j++) {
			if(map[i][j]=='#' && !vis[i][j]) {
				dfs(i,j,num);
				num++;
			}
		}
	}
	int ans=0;
	for(int i=0;i<num;i++) {
		if(f[i] == 0) {
			ans++;
		}
	}
	cout<<ans<<endl;
	
	return 0;
}
```